#!/usr/bin/env python3
"""Export machine-readable and LaTeX-consumable metric bundles for reports."""

from __future__ import annotations

import argparse
import json
from pathlib import Path
from typing import Any, Dict

METRIC_EXPORT_VERSION = "2.0"
PROJECT_ROOT = Path(__file__).resolve().parents[1]
DEFAULT_SOLUTIONS_DIR = PROJECT_ROOT / "solutions"
DEFAULT_RUN_SUMMARY = DEFAULT_SOLUTIONS_DIR / "run_summary.json"

LATEX_MACRO_MAP = {
    "metric_export_version": "MetricExportVersion",
    "runtime_profile": "MetricRuntimeProfile",
    "data_split_strategy": "MetricDataSplitStrategy",
    "q6_model": "MetricQSixModel",
    "q6_accuracy": "MetricQSixAccuracy",
    "q6_auc": "MetricQSixAuc",
    "q6_f1": "MetricQSixFOne",
    "q15_brier": "MetricQFifteenBrier",
    "q15_ece": "MetricQFifteenEce",
    "q15_best_f1_threshold": "MetricQFifteenBestFOneThreshold",
    "q16_top_feature": "MetricQSixteenTopFeature",
    "q16_top_psi": "MetricQSixteenTopPsi",
    "q17_recourse_rate": "MetricQSeventeenRecourseRate",
    "q18_mean_auc": "MetricQEighteenMeanAuc",
    "q18_auc_decay": "MetricQEighteenAucDecay",
    "q19_cov90": "MetricQNineteenCovNinety",
    "q19_max_undercoverage": "MetricQNineteenMaxUndercoverage",
    "q20_dp_gap_base": "MetricQTwentyDpGapBase",
    "q20_dp_gap_mitigated": "MetricQTwentyDpGapMitigated",
    "q20_policy_pass": "MetricQTwentyPolicyPass",
}


def _nested_get(obj: Dict[str, Any], *keys: str, default: Any = float("nan")) -> Any:
    cur: Any = obj
    for key in keys:
        if not isinstance(cur, dict) or key not in cur:
            return default
        cur = cur[key]
    return cur


def collect_report_metrics(summary: Dict[str, Any]) -> Dict[str, Any]:
    metrics: Dict[str, Any] = {
        "metric_export_version": METRIC_EXPORT_VERSION,
        "runtime_profile": summary.get("runtime_profile", "unknown"),
        "data_split_strategy": summary.get("data_split_strategy", "unknown"),
        "q6_model": _nested_get(summary, "q6", "model_name", default="unknown"),
        "q6_accuracy": _nested_get(summary, "q6", "accuracy"),
        "q6_auc": _nested_get(summary, "q6", "roc_auc"),
        "q6_f1": _nested_get(summary, "q6", "f1"),
        "q15_brier": _nested_get(summary, "q15", "brier_score"),
        "q15_ece": _nested_get(summary, "q15", "expected_calibration_error"),
        "q15_best_f1_threshold": _nested_get(summary, "q15", "best_f1_threshold"),
        "q16_top_feature": _nested_get(summary, "q16", "top_drift_feature", default="N/A"),
        "q16_top_psi": _nested_get(summary, "q16", "top_drift_psi"),
        "q17_recourse_rate": _nested_get(summary, "q17", "recourse_success_rate"),
        "q18_mean_auc": _nested_get(summary, "q18", "mean_auc"),
        "q18_auc_decay": _nested_get(summary, "q18", "auc_decay_absolute"),
        "q19_cov90": _nested_get(summary, "q19", "coverage_at_90"),
        "q19_max_undercoverage": _nested_get(summary, "q19", "max_under_coverage_gap"),
        "q20_dp_gap_base": _nested_get(summary, "q20", "baseline_demographic_parity_gap"),
        "q20_dp_gap_mitigated": _nested_get(summary, "q20", "mitigated_demographic_parity_gap"),
        "q20_policy_pass": _nested_get(summary, "q20", "policy_pass", default=False),
    }
    return metrics


def _tex_safe_value(value: Any) -> str:
    if isinstance(value, bool):
        return "true" if value else "false"
    if isinstance(value, (int, float)):
        if value != value:  # NaN check
            return "N/A"
        return f"{value:.4f}"
    text = str(value)
    return text.replace("_", "\\_")


def write_latex_metrics_tex(metrics: Dict[str, Any], output_path: Path) -> None:
    lines = ["% Auto-generated by report_metrics_export.py", f"% metric_export_version={METRIC_EXPORT_VERSION}"]
    for key in sorted(metrics.keys()):
        macro = LATEX_MACRO_MAP.get(key)
        if macro is None:
            continue
        value = _tex_safe_value(metrics[key])
        lines.append(f"\\newcommand{{\\{macro}}}{{{value}}}")
    output_path.write_text("\n".join(lines) + "\n", encoding="utf-8")


def export_metrics_files(summary: Dict[str, Any], solutions_dir: Path) -> Dict[str, str]:
    solutions_dir.mkdir(parents=True, exist_ok=True)
    metrics = collect_report_metrics(summary)

    json_path = solutions_dir / "latex_metrics.json"
    tex_path = solutions_dir / "latex_metrics.tex"

    json_path.write_text(json.dumps(metrics, indent=2, ensure_ascii=False), encoding="utf-8")
    write_latex_metrics_tex(metrics, tex_path)

    return {
        "latex_metrics_json": str(json_path),
        "latex_metrics_tex": str(tex_path),
        "metric_export_version": METRIC_EXPORT_VERSION,
    }


def main() -> None:
    parser = argparse.ArgumentParser(description="Export report metrics from run_summary.json.")
    parser.add_argument("--summary", type=Path, default=DEFAULT_RUN_SUMMARY)
    parser.add_argument("--solutions-dir", type=Path, default=DEFAULT_SOLUTIONS_DIR)
    args = parser.parse_args()

    summary = json.loads(args.summary.read_text(encoding="utf-8"))
    out = export_metrics_files(summary, args.solutions_dir)
    print("Exported metrics:")
    print(json.dumps(out, indent=2))


if __name__ == "__main__":
    main()
